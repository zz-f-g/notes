# 数据结构

微信群

公共邮箱（ppt）：dqgcswz@163.com

密码：jiading0705

助教邮箱（交作业）：2030825@tongji.edu.cn

[TOC]

---

## 物理结构

数据在计算机中如何存放（映像）

与算法的最终实现有关

- 顺序（节省空间，但增删元素困难）
  - 连续存放
  - 逻辑相邻
  - 物理上也相邻
- 链表（增删方便，但节点复杂，还要存储后继元素的地址）
  - 非连续存放
  - 指向后续节点的指针域
  - 分类
    - 单向
    - 双向
    - 循环
- 索引（预先分成几个部分）
- 散列（哈希表）：按照带存储的数对特定数的余数（运算）存储，余数相同的放在一起。
  - 数据和地址之间存在一种运算关系
  - 当余数相同时可能会出现冲突（同义词）

### 顺序存储结构

线性表的顺序存储结构：顺序表

$adr(a_i)=adr(a_1)+(i-1)*L$，其中 ***L*** 表示每个数据存储占据的长度。

顺序存储的特点

- 数据连续存放、==随机存取==（无论 i 为何值，找到第 i 个元素的时间相同）
- 逻辑和物理上均相邻
- 存储结构简单、易于实现
- 插入删除操作不便
- 存储密度大，空间利用率高

运算

- 置空初始化
- 求长度
- 按位置查找
- 取前趋、后继
- 按值查找
- 插入、删除
- 判断是否为空

```C
void show_arr(int list[], int* p_last);
int list_insert(int list[], int* p_last, int index, int var);
int list_del(int list[], int* p_last, int index);

int main(void){
    int list[MAXLEN] = {1,2,3,4,5};
    int last = 5; //the index of the last element
    int* p_last = &last;
    int res;
    int state = list_insert(list, p_last, 4, 6);
    if(state >= 0){
        show_arr(list, p_last);
        printf("%d elements in list.\n", last);
    }
    res = list_del(list, p_last, 5);
    if(res != 0){
        show_arr(list, p_last);
        printf("%d elements in list.\n", last);
        printf("%d", res);
    }
    return 0;
}

void show_arr(int list[], int* p_last){
    int i;
    for(i=0; i<*p_last; i++){
        printf("%d\t", list[i]);
    }
    printf("\n");
}

/*插入算法*/
int list_insert(int list[], int* ptr_n, int index, int var){
    int i;
    if(MAXLEN==*ptr_n){
        printf("No other space!\n");
        return -1;
    }
    if(index<0 || index>*ptr_n){
        printf("Wrong index to insert!\n");
        return -2;
    }
    for(i=*ptr_n-1; i>=index; i--){
        list[i+1] = list[i];
    }
    list[index] = var;
    *ptr_n += 1;//这不能是递增运算符
    return 0;
}

/*删除算法*/
int list_del(int list[], int* p_last, int index){
    int res;
    int i;
    if(index<0 || index>=*p_last){
        printf("Wrong index to delete!\n");
        return -1;
    }
    res = list[index];
    for(i=index; i<*p_last-1; i++){
        list[i] = list[i+1];
    }
    *p_last -= 1;//这不能是递减运算符
    return res;
}
```

### 链式存储结构

线性表的链式存储结构：链表，一种==顺序存取==的存储结构（相比顺序表的==随机存取==）

```C
struct node{
    int data;
    struct node *next;
};
typedef struct node NODE;
```

#### 链表基本概念

- 借助指针表示逻辑关系
- 链表（LINK）：由结点构成
- 头指针：指向链表第一个结点，不储存数据
- 首元结点：存储第一个有效数据

头结点的存在使得空表和非空表形式在头结点上得到统一：

- ``head = NULL``

- ``head->next = NULL``

#### 单链表的操作

- 指针的基本操作

```c
struct node{
    int data;
    struct node *next;
};
typedef struct node NODE;

NODE *p;
NODE *q;
p = (NODE*)malloc(sizeof(NODE)); //申请一个节点空间，并将节点地址送入指针变量中
free(p); //释放节点空间
p = q->next;
```

- 查找

- 插入

- 删除

```C
struct node{
    int data;
    struct node *next;
};
typedef struct node NODE;

NODE* create_link(void);
NODE* create_link_reverse(void);
void show_link(NODE* head);
void del_link(NODE* head); //without debug
NODE* get_NODE(NODE* head, int index);
int get_index(NODE* head, int start, int var); //without debug
int insert_var(NODE* head, int index, int var);
int del_var(NODE* head, int index);


int main(void){
    NODE *head;
    int var;
    int i;

    head = create_link();
    show_link(head);
//    del_link(head); //some problem
//    i = get_index(head, 0, 3);
//    printf("3 is at %d.\n", i); //some problem
    insert_var(head, 1, 9);
    del_var(head, 4);
    show_link(head);
    return 0;
}

NODE* create_link(void){
    NODE* head;
    NODE* cur;
    NODE* prev;
    head = (NODE*)malloc(sizeof(NODE));
    head->data = 0; //without debug
    cur = (NODE*)malloc(sizeof(NODE));
    prev = head;
    printf("Input value:('q' to quit)\n");
    while(1==scanf("%d", &(cur->data))){
        printf("Got it!\n");
        printf("Input value:('q' to quit)\n");
        prev->next = cur;
        prev = cur;
        cur = (NODE*)malloc(sizeof(NODE));
    }
    prev->next = NULL;
    free(cur);
    return head;
}

NODE* create_link_reverse(void){
    NODE* head;
    NODE* cur;
    int var;
    head = (NODE*)malloc(sizeof(NODE));
    head->next = NULL;
    printf("Input value in reverse:('q' to quit)\n");
    if(1==scanf("%d", &(head->data))){
        printf("Got it!\n");
        printf("Input value in reverse:('q' to quit)\n");
        while(1==scanf("%d", &var)){
            cur = (NODE*)malloc(sizeof(NODE));
            cur->data = var;
            cur->next = head;
            head = cur;
            printf("Got it!\n");
            printf("Input value in reverse:('q' to quit)\n");
        }
        printf("Quit Input!\n");
        head = (NODE*)malloc(sizeof(NODE));
        head->next = cur;
        head->data = 0;
    }
    return head;
}

void show_link(NODE* head){
    NODE* cur;
    cur = head->next;
    while(cur != NULL){
        printf("%d\t", cur->data);
        cur = cur->next;
    }
    printf("\n");
}

void del_link(NODE* head){
    NODE* cur;
    cur = head;
    while(head != NULL){
        head = cur->next;
        free(cur);
        cur = head;
    }
}

NODE* get_NODE(NODE *head,int i){
    NODE *p;
    int cnt = 0;
    p=head;
    while((p!=NULL)&&(cnt<i)){
        p=p->next;
        cnt++;
    }
    if((p!=NULL)&&(cnt == i))
        return p;
    else
        return NULL;
}


int insert_var(NODE* head, int index, int var){
    NODE *cur, *new;
    cur = get_NODE(head, index-1);
    if(cur == NULL){
        printf("Wrong index to insert!\n");
        return -1;
    }else{
        new = (NODE*)malloc(sizeof(NODE));
        new->data = var;
        new->next = cur->next;
        cur->next = new;
        return 0;
    }
}

int del_var(NODE* head, int index){
    NODE *cur, *del;
    int res;
    cur = get_NODE(head, index-1);
    if((cur == NULL) || (cur->next == NULL)){
        printf("Wrong index to delete!\n");
        return -1;
    }else{
        del = cur->next;
        cur->next = del->next;
        res = del->data;
        free(del);
        return res;
    }
}

int get_index(NODE* head, int start, int var){
    NODE *p;
    int cnt = 0;
    p=head;
    while((p!=NULL)&&(var != p->data)){
        p=p->next;
        cnt++;
    }
    if((p!=NULL)&&(var != p->data))
        return cnt;
    else
        return -1;
}
```

#### 单循环链表

最后一个结点的指针指向头节点

- 从表中任意一个节点出发都可以找到其他节点
- 找到前趋节点的时间复杂度是 $O(n)$

#### 双向循环链表

每个节点包括：

- 数据域
- 前趋
- 后继

```C
struct dnode{
    int data;
    struct dnode *prior, *next;
};
typedef struct dnode DNODE;
```

特点

- 适合两个方向的运动
- 找前趋的时间复杂度为 $O(1)$

---

## 逻辑结构

$$
DS=(D,R)
$$

*D*：数据元素的有限集合

*R*：元素之间的关系集合

与算法的设计有关

- 线性数据结构 Linear Data Structrue
  - 线性表
  - 栈（原始森林中找到回家的路）stack
  - 队列（两个地址：队首和队尾）
  - 数组
    - 稀疏矩阵（节约数据量，只存储非零数据）
  - 串
- 非线性数据结构：非唯一的前趋和后继
  - 树（级别分支关系、一对多）
    - 二叉树：分支最多两个
    - Huffman 编码——最优二叉树
  - 图（多对多的关系）
    - 八皇后问题
  - 集合

### 线性表

数据元素一一对应的线性关系

``Linear_list = (D, R)``
$$
D = \{a_1, a_2, \cdots, a_n\} \\
R = \{<a_{i-1}, a_i> | a_{i-1}, a_i \in D, i = 2,\cdots, n\}
$$

#### 线性表的特点

- 唯一的前趋和后继
- 各元素数据类型必须相同
- 各元素排列有序

#### 线性表的运算

- 置空初始化
- 求长度
- 按位置查找
- 取前趋、后继
- 按值查找
- 插入、删除
- 判断是否为空

### 栈

#### 栈的定义

允许在同一端（栈顶）进行插入和删除的特殊线性表。另一端被称为栈底。栈也被称为后进先出表。栈顶指针记为 ``top``.

栈的上溢出、下溢出条件

- 上溢出 ``top = MAXSIZE``
- 下溢出 ``top = -1``；栈空条件为 ``top = 0``

#### 栈的基本运算

- 初始化为空
- 判断是否为空
- 进栈
- 出栈
- 取栈顶元素（不改变栈）

#### 栈的顺序存储

采用数组存储

```c
int top = 0;
int stack[MAXSIZE];
```

==先加一后入栈，先出栈后减一==

入栈的顺序规定好，但是入栈的过程中允许出栈。对于 n 个元素的入栈并全出栈，所有的出栈排列数为卡特兰数：
$$
\text{Catalan Number: } \frac{\binom{2n}{n}}{n+1}
$$

用字符串数组表示所有入栈元素的顺序，输出所有的出栈排列，计算卡特兰数的程序：

```C

```

#### 多栈共享

充分利用存储空间。这段空间的两端设为两个栈的栈底，入栈时栈顶向中间移动。这是**双向栈**。

栈顶指针相遇时栈满。 ``top1 == top2``

#### 栈的链式存储

最大空间需求事先不知道。

栈顶指针是头指针。

#### 栈的应用

### 队列

#### 队列的定义

只允许在前端进行删除，在后端进行插入。

#### 队列的基本运算

清空队列

判断是否为空（队尾指针等于队首指针）

插入、删除

#### 队列的顺序存储结构

队头元素前一个位置（空位置）为队头指针。这样对于任意的队头元素要出队：

```c
front = front + 1;
x = queue[front];
```

队尾元素为队尾指针。

#### 循环队列的存储结构

循环队列的设计目的：防止“假溢出”。

对指针采用求余数的方法：

```C
void ADDCQ(int CQ[], int m, int front, int rear, int x){
    front = rear = m-1;
    if(front == ((rear + 1) % m)){
        printf("Full\n");
        exit(-1);
    }else{
        rear = (rear + 1) % m;
        CQ[rear] = x;
    }
}

void DELQUEUE(){
    int y;
    if(front == rear){
        printf("Empty\n");
        y = -1;
    }else{
        front = (front + 1) % m;
        y = CQ[front];
    }
}
```

队满条件：

队头元素和队尾元素之间有一个空间。

#### 队列的链式存储结构

头节点为空。

链满的条件：``T = NULL``

新申请的节点为空，内存无空间。

```C
addqueue(int x){
    QNODE *t;
    t = (QNODE*)malloc(sizeof(QNODE));
    if(t == NULL){
        printf("FULL\n"); //内存无可用空间
        exit(-1);
    }else{
        rear -> next = t;
        rear = t;
        t -> data = x;
        t -> next = NULL; //尾节点无后继
    }
}
```

进行删除时需要注意：

- 当队列长度不为 1 时，出队只需要修改头节点（改为指向后一个元素）。
- 当队列长度为 1 时，出队不仅需要修改头节点（``head -> next = NULL``），还需要修改队尾指针（``rear = head``）。
- 判断长度为 1 的方法：要删除的节点指针域是否为 1.

```C
delqueue(){
    int x;
    QNODE *t;
    if(front == rear){
        printf("Empty\n");
        exit(1);
    }else{
        t = front -> next;
        front -> next = t -> next;
        if(t -> next == NULL)
            rear = front;
        free(t);
    }
}
```

#### 队列的应用

- 多道任务中的 CPU 管理
- 缓冲区的设计

### 数组

#### 数组的定义

相同类型数据元素的有限集合

数组元素可以用数组名和下标唯一确定

二维数组：``2_ARRAY=(K, R)``

基本操作：

- 给定下标，存入或修改相应元素

只能采用顺序存储结构，两种存储方式：

- 按行优先
  - 二维数组 $A_{m \times n}$ 地址计算公式：$LOC(a_{ij}) = LOC(a_{11})+(i-1)*n+j-1$
  - 三维数组 $A_{l \times m \times n}$：先排右下标，再排左下标；地址计算公式：$LOC(a_{ijk}) = LOC(a_{111})+mn(i-1)+n(j-1)+k-1$
- 按列优先
  - 二维数组 $A_{m \times n}$ 地址计算公式：$LOC(a_{ij}) = LOC(a_{11})+(j-1)*m+i-1$
  - 三维数组 $A_{l \times m \times n}$：先排左下标，再排左下标；地址计算公式：$LOC(a_{ijk}) = LOC(a_{111})+lm(k-1)+l(j-1)+i-1$

#### 数组的储存结构

压缩存储

- 定义
  - 相同值的多个元素占用一个存储单元
  - 0 元素不分配存储
- 例子
  - 对称矩阵：只存储主对角线以上（下）的元素；$LOC(a_{ij}) = LOC(a_{11})+j+i(i-1)/2$
  - 三角矩阵
  - 带状矩阵
  - 稀疏矩阵：只存储非零元素
  - 大量相同元素

#### 特殊矩阵的存储和管理

稀疏矩阵：三元组（第几行、第几列，非零元素是什么）

矩阵转置算法：P47 / P49（第二次编程大作业）

带辅助向量的三元组表示

#### 数组的链式存储结构

行指针向量

#### 数组的应用

Josephus problem

n 个元素形成一圈，第 m 个出列，求最后剩下的原来的序数。

算法：

- 循环单链表
- 数组（跳过出队元素）
- 数组（删除出队元素以后后续元素前移）

数组方法：

```C
int k; //已经出队的元素个数
int j; //报数计数器
```

### 树

#### 树的基本概念

- 唯一的根
- 每一个元素唯一的前趋
- 后继（有或没有）

#### 树的逻辑结构

结点：树上的元素

度：结点拥有的子树数

叶子：树的末端（度为 0）

父节点、子节点、深度、有序树、无序树

```C
PARENT(n,T)
ROOT(T)
CHILD(T,x,i)
CREATE(x,T1,T2,T3)
```

#### 存储结构及实现

多重链表（每一个节点有多个指针域）

- 结点异构型：各节点的度不同，域也不同。
- 结点同构型：按照树的度设置指针，指针域相同。

解决两种方法的缺陷：转化为二叉树。

- 将兄弟节点转化为右子树
- 将子结点中的一个转化为左子树
- 递归操作

二叉树的重要性质

- 任意二叉树，度为 0 的结点比度为 2 的结点数量多一。
- 具有 n 个结点的二叉树，深度至少是 $[\log_2 n]$。

几种特殊二叉树

- 满二叉树：深度为 h，结点树为 $2^h - 1$.
- 完全二叉树：只能是最后一层缺结点，且必须从右往左缺。（只有这种可以使用顺序存储）
  - 度为 1 的结点最多有 1 个。
- 平衡二叉树：每个结点的平衡因子只能取值 -1，0，1.（平衡因子 = 结点的左子树的深度 - 右节点的深度）

#### 遍历算法

- 先序
- 中序（==普通的树是没有中序遍历的，因为没有强制规定左右==）
- 后序

知道一颗二叉树的中序遍历以后，再知道先序遍历或后序遍历中的一个就可以反向推导出二叉树的结构。但是，只知道先序遍历和后序遍历，不知道中序遍历是不可以得出结构的。

#### 特殊二叉树的表示及性质

#### 二叉树的应用

##### 二叉排序树

定义：空树或满足下述条件的树。

$var(leftNode) \leq var(rootNode) \leq var(rightNode)$

中序遍历得到从小到大排列的序列。

插入算法：

- 第一个数值存入根节点
- 后续数值与根节点比较
  - 如果大于根节点，进入右子树，重复比较操作直到待比较的子树为空
  - 如果小于根节点，进入左子树，重复比较操作直到待比较的子树为空
- 在待比较的空子树的位置新建节点，存入数值

```C

```

删除算法：

- 如果待删除结点是叶子节点，修改父节点指针；
- 如果待删除结点只有一个子树，修改父节点的指针指向子树的根节点；
- 如果待删除结点有两个子树，

##### 最优二叉树（哈夫曼树）

定义：带权路径最短。

路径长度：一个节点到另一个结点之间的分支数目。

### 图

$$
G = (V, R)
$$

#### 图的基本概念

- 有向图
- 无向图
- 网（图中每一个边附带一个权）
- 邻接点
- 顶点
- 边（无向图）
- 弧（有向图）
- 顶点的度（有向图分为出度（自己指向）和入度（指向自己））
- 路径、有向路径、简单路径、简单回路
- 连通图（任意两个结点连通）：任意两个顶点连通
- 连通分量：无向图中的最大连通子图

有向图的偶对 $R$：边 $(v_1, v_2)$

无向图的偶对 $R$：弧 $<v_1, v_2>$ $v_2$ 是 $v_1$ 的邻接点。

路径：从 $v_x$ 到 $v_y$ 的顶点序列。

长度：沿着该路径的边或弧的个数。

连通：无向图的每一对顶点之间都存在路径。

完全无向图：任意两个节点都有直达的边。

连通分量：非连通无向图中的极大连通子图。（一个连通的块）

强连通图：有向图中任意两个节点都存在正向和反向的路径。

网：边或弧上带权重的图。

#### 存储结构

##### 邻接矩阵

- 用一个一维数组存放顶点
- 用一个二维数组存放顶点之间的关系，这个二维矩阵称为邻接矩阵

$$
\begin{equation}
A[i,j] = \left\{
\begin{array}{rcl}
w_{ij} && <v_x, v_y> \in R \\
0 && <v_x, v_y> \notin R
\end{array} \right.
\end{equation}
$$

无向图的邻接矩阵对称。

当图为网时，$w_{ij}$ 表示该边或弧的权重；否则 $w_{ij} = 1$.

无向图度为 $\sum_{i=1}^n A[i,j] = \sum_{j=1}^n A[i,j]$

有向图行为出度，列为入度。

当且仅当节点的入度为 0 时，可以删除该节点。

##### 邻接表

对图的每个顶点建立一个单链表。单链表中的每个节点包含以该顶点为起点的边或弧的信息：

- 邻接域（adjvex）：边或者弧的终点
- 表结点（data）：边或者弧的信息，如权值
- 链域（nextarc）：下一个储存弧信息的节点的指针

然后再用一个顺序储存结构储存这些链表的头节点。头节点包括：

- 数据域（vexdata）：顶点的数据
- 链域（firarc）：指向单链表第一个节点

```C
struct arcnode{
    int adjvex;
    float data;
    struct arcnode *nextarc;
}

struct headnode{
    int vexdata;
    struct arcnode *firarc;
}
```

#### 图的遍历

为了防止重复，需要建立辅助数组 ``visited[n]``，储存已经访问的顶点。

- 深度优先
- 广度优先

## 算法

### 特点

- 有穷性
- 确定性
- 可行性
- 输入（>0）
- 输出（>1）

### 设计基本方法

- 列举
- 归纳
- 递推
- 递归
- 减半递推技术：减半指的是将问题的规模减半，递推指的是重复减半的过程。例如二分法。
- 回溯：沿着一条可能的线索进行试探，如果失败回到上一步。

八皇后问题

```C
void queen(int n){
    int i, j, k, jt, *q;
    q = malloc(n * sizeof(int));
    for(i=0; i<n; i++)
        q[i] = 0;
    i=0;
    jt=1;
    printf("\n");
    printf("%d queen problem\n", n);

    while(1==jt){
        if(q[i]<n){
            k = 0;
            while((k<i) && ((q[k]-q[i])*(fabs(q[k]-q[i])-fabs(k-i)))!=0)
                k = k + 1;
            if(k<i)
                q[i] = q[i] + 1;
            else{
                i = i + 1;
                if(i>n-1){
                    for(j=0; j<n; j++)
                        printf("%5d", q[j]+1);
                    printf("\n");
                    q[n-1] = q[n-1] + 1;
                    i = n - 1;
                }
            }
        }else{
            q[i]=0;
            i = i - 1;
            if(i<0){
                printf("\n");
                free(q);
                return;
            }
            q[i] = q[i] + 1;
        }
    }
}

int main(void){
    queen(8);
    return 0;
}
```

算法的描述方式：类高级语言

### 算法的评价

#### 时间复杂度（花的时间）

得出：

- 计算语句的执行次数
- 去掉低次项和常数项
- 去掉最高次项的系数

类型：

- 常数型
- 对数型
- 线性型
- 平方型

#### 空间复杂度（额外申请的空间）

算法在计算机上运行所占据的存储空间。度量同时间复杂度。

### 查找

- 线性查找
- 二分查找
  - 二叉排序树
- 分块查找：每一块中最小的比另一块的最大的大
- 哈希查找

#### 平均查找长度

$$
ASL = \sum_{i=1}^n P_i C_i
$$

其中，$P_i$ 为查找某一个元素的概率，$C_i$ 为找到这个元素需要比较的次数。

#### 线性查找

从第一个元素一直比较到最后一个元素，既适用于顺序结构，也适用于链式结构。

```C
int seq_search(int* A, int n, int key){
    int i = 0;
    while(A[i] != key){
        i
```

另一种方法：设置监视哨。

```C
int seq_search_a(int* A, int n, int key){
    int i = 0;
    A[n] = key; //***
    while(A[i] != key){
        i++;
    }
    if(i < n){
        return i;
    }else{
        return -1;
    }
}
```

平均查找长度：
$$
ASL = \frac{1}{n} \sum_{i=1}^{n} i = \frac{n+1}{2}
$$

#### 对分查找

条件：查找表中的元素有序。

采用递归思想。

==某一个元素在有序表中的位置和找到它的次数有关。==

平均查找长度：
$$
ASL \leq \log_2 n
$$

#### 分块查找

条件：分块有序（文件按照关键字分为若干块，前一块的最大的关键字小于后一块中最小的关键字，而每一块的关键字不一定有序）

基本思想：先将各块中最大关键字构成一个索引表，索引表递增有序。

步骤：

1. 对索引表进行对分或者顺序查找，确定在哪一块；
2. 在所在的块中进行顺序查找。

索引表

```C
typedef struct index{
    int key; //块中的最大元素
    int* link; //指向块的入口地址
}INDEX;
```

优点

- 插入删除方便
- 只要找到对应的块，在块中任意位置进行操作即可

缺点

- 额外的存储空间

#### 二叉排序树查找

综合了：

- 对分排序的高效
- 链表的灵活性

$$
ASL = \log_2 n
$$

防止二叉树退化成单支树，要进行平衡化处理。

#### 哈希查找

地址和值有关：
$$
Addr = H(key)
$$
$H$ 称为哈希函数。一般来说是求余数。
$$
H(key) = \mathrm{mod}_p(key)
$$
$p$ 为大于哈希表长的数。

哈希表中的冲突：
$$
H(key_1) = H(key_2)
$$
解决必须寻找下一个可用地址：

- 开放地址法

$$
H_i = \mathrm{mod}_m (H(key) + di)
$$

$m$ 为哈希表长，$di$ 为散列。三种散列对应三种方法

1. 线性探测再散列

2. 平方探测再散列

3. 随即探测再散列
- 链地址法

### 排序

内排序：调到内存中。

- 选择：简单、堆
- 插入：直接插入、希尔
- 交换：冒泡
- 归并
- 基数

简单选择排序：找出关键字最小的元素，把它与第一个记录交换存储位置。对后面的序列进行递归操作。

#### 堆排序

堆（完全二叉树）

- 大顶堆

$$
k_i \geq k_{2i} \\
k_i \geq k_{2i + 1} \\
\forall i \leq [\frac{n}{2}]
$$

- 小顶堆

$$
k_i \leq k_{2i} \\
k_i \leq k_{2i + 1} \\
\forall i \leq [\frac{n}{2}]
$$

堆的建立?

删除堆顶元素：将堆顶元素和堆尾元素交换，之后将前面的重新建堆，再交换，以此类推。

#### 直接插入排序

将未排序的插入已排序的数据结构中。

```C
void insertSort(int R[], int n){
    int i,j;
    for(i=2; i<=n; i++){
        R[0] = R[i]; // R[0] 是监视哨
        j = i - 1;
        while(R[0] < R[j]){
            R[j+1]
        }
    }
}
```

#### 对半插入排序

先对半查找，后移动。

#### 冒泡排序

逐次扫描，逆序交换。

#### 快速排序

**偏爱**无次序的序列。

通过实现二分划分，来递归。

二分划分的步骤：

- 选取第一个元素为划分支点。
- 与递减指针 ``j`` 所指元素比较，如果支点大，则交换。再交替与递增指针 ``i`` 比较，如果支点小，则交换。
- 直到两个指针 ``i, j`` 相遇为止。

给定一组关键字：
$$
41,62,13,84,35,96,57,39,79,61,15,83
$$

插入排序
$$
\begin{align*}
41,62 \\
13,41,62 \\
13,41,62,84 \\
13,35,42,62,84 \\
13,35,42,62,84,96 \\
13,35,42,57,62,84,96 \\
13,35,39,42,57,62,84,96 \\
13,35,39,42,57,62,79,84,96 \\
13,35,39,42,57,61,62,79,84,96 \\
13,15,35,39,42,57,61,62,79,84,96 \\
13,15,35,39,42,57,61,62,79,83,84,96
\end{align*}
$$

简单选择排序
$$
\begin{align*}
13,62,41,84,35,96,57,39,79,61,15,83 \\
13,15,41,84,35,96,57,39,79,61,62,83 \\
13,15,35,84,41,96,57,39,79,61,62,83 \\
13,15,35,39,41,96,57,84,79,61,62,83 \\
13,15,35,39,41,96,57,84,79,61,62,83 \\
13,15,35,39,41,57,96,84,79,61,62,83 \\
13,15,35,39,41,57,61,84,79,96,62,83 \\
13,15,35,39,41,57,61,62,79,96,84,83 \\
13,15,35,39,41,57,61,62,79,96,84,83 \\
13,15,35,39,41,57,61,62,79,83,84,96 \\
13,15,35,39,41,57,61,62,79,83,84,96
\end{align*}
$$

堆排序
$$
\begin{align*}
41,62,13,84,35,96,57,39,79,61,15,83 \\
41,62,13,84,35,96,57,39,79,61,15,83 \\
41,62,13,84,61,96,57,39,79,35,15,83 \\
41,62,13,84,61,96,57,39,79,35,15,83 \\
41,62,96,84,61,13,57,39,79,35,15,83 \\
41,62,96,84,61,83,57,39,79,35,15,13 \\
41,84,96,62,61,83,57,39,79,35,15,13 \\
41,84,96,79,61,83,57,39,62,35,15,13 \\
96,84,41,79,61,83,57,39,62,35,15,13 \\
96,84,83,79,61,41,57,39,62,35,15,13 \\
\text{Built!} \\
13,84,83,79,61,41,57,39,62,35,15,96 \\
84,13,83,79,61,41,57,39,62,35,15,96 \\
84,79,83,13,61,41,57,39,62,35,15,96 \\
84,79,83,62,61,41,57,39,13,35,15,96 \\
84,79,83,62,61,41,57,39,13,35,15,96 \\
15,79,83,62,61,41,57,39,13,35,84,96 \\
83,79,15,62,61,41,57,39,13,35,84,96 \\
83,79,57,62,61,41,15,39,13,35,84,96 \\
35,79,57,62,61,41,15,39,13,83,84,96 \\
79,35,57,62,61,41,15,39,13,83,84,96 \\
79,62,57,35,61,41,15,39,13,83,84,96 \\
79,62,57,39,61,41,15,35,13,83,84,96 \\
13,62,57,39,61,41,15,35,79,83,84,96 \\
62,13,57,39,61,41,15,35,79,83,84,96 \\
62,61,57,39,13,41,15,35,79,83,84,96 \\
62,61,57,39,13,41,15,35,79,83,84,96 \\
35,61,57,39,13,41,15,62,79,83,84,96 \\
61,35,57,39,13,41,15,62,79,83,84,96 \\
61,39,57,35,13,41,15,62,79,83,84,96 \\
15,39,57,35,13,41,61,62,79,83,84,96 \\
57,39,15,35,13,41,61,62,79,83,84,96 \\
57,39,41,35,13,15,61,62,79,83,84,96 \\
15,39,41,35,13,57,61,62,79,83,84,96 \\
41,39,15,35,13,57,61,62,79,83,84,96 \\
13,39,15,35,41,57,61,62,79,83,84,96 \\
39,13,15,35,41,57,61,62,79,83,84,96 \\
39,35,15,13,41,57,61,62,79,83,84,96 \\
13,35,15,39,41,57,61,62,79,83,84,96 \\
35,13,15,39,41,57,61,62,79,83,84,96 \\
15,13,35,39,41,57,61,62,79,83,84,96 \\
13,15,35,39,41,57,61,62,79,83,84,96 \\
\end{align*}
$$

复习题

1. 线性表、树、图、集合
2. 元素和关系
3. 循环队列克服假溢出
4. 在单链表中，除了头节点外，任一节点的存储位置由前驱节点的 next 指针域指示
5. 对于一颗具有 n 个节点的树，其所有节点的度的和为 $n-1$
6. 在一颗非空树中，有 1 个根节点，其余的节点分成 m 个==互不相交==的集合，每个集合都是根节点的子树。
7. 树中某节点的子树的个数称为该节点的度，子树的根节点称为该节点的孩子，该节点称为其子树根节点的双亲。
8. 在具有 n 个节点的二叉链表中，共有 $2n$ 个指针域，其中 $n-1$ 个指针域用于指向其左右孩子，剩下的 $n+1$ 个指针域则是空的。==二叉树不是树的特殊形式。==
9. 任何连通图的连通分量只有一个，既是==它本身==。
10. 已知一个有向图的邻接矩阵表示，计算第 j 个顶点的入度的方法是计算邻接矩阵第 j 列的非零元素个数。行计算出度。
11. 有向图不存在回路，则所有节点构成拓扑序列。
12. 数列 $\{25,30,8,5,1,27,24,10,20,21,9,28,7,13,15\}$ 如果用线性结构存储，查找一个数的平均比较次数为 $\frac{16 \times 15}{2 \times 15}$；如果用二叉排序树储存，则查找一个数的平均查找次数为 $\frac{59}{15}$
13. 数列 $\{25,43,62,61,48,56\}$ 散列函数 $H(k) = k \mathrm{mod} 7$，则元素 48 的同义词是 62. 可以通过两种方法，散列（顺序，平方，随机）和链地址
14. 在各种查找方法中，平均查找长度和结点个数无关的是哈希查找
15. 排序的主要目的是为了以后对已经排序的数据元素对分查找。
16. 对 $\{54,38,96,23,15,72,60,45,83\}$ 当把第 7 个记录 60 插入到有序表时，需要比较 3 次，和 96，72，54 比较。
17. 评价排序的时间，主要标准是比较次数和交换次数。
18. 高效性不是算法必须具备的性能，有穷性，确切性，可行性是必须具备的。
19. 顺序存储不是顺序存取，是随机存取；链式存储是顺序存取（必须挨个查找）
20. 链栈的存储顺序是反的。栈顶指针是头指针。
21. 二叉树的前序序列和后序序列正好相反，那么一定是高度等于结点数的二叉树。
22. 前序遍历和中序遍历结果相同的二叉树是所有结点只有右子树的二叉树。
23. 讨论树、森林、二叉树的关系，目的是将树、森林按二叉树的存储关系进行存储并利用二叉树的算法解决树的有关问题。
24. 一个图的邻接矩阵唯一但是邻接表不唯一（每个邻接表的表中的相邻顶点顺序可以不同）。邻接矩阵的阶数等于顶点的个数。
25. 设有 5000 个元素，希望用最快的方法找出前 10 个最大的，采用什么排序方法最好——堆排序。
26. 不是所有的数据结构都有三个基本操作：插入、删除和查找。

选择 $10 \times 2 = 20$

判断 $10 \times 1 = 10$

综合

- 分析
- 写
